{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../App.svelte",
    "../Button.svelte",
    "../Canvas.svelte",
    "../ConnectionSVG.svelte",
    "../FlowModule.svelte",
    "../FlowModuleContent.svelte",
    "../FlowModuleHeader.svelte",
    "../FlowModuleInput.svelte",
    "../FlowModuleOutput.svelte",
    "../Modal.svelte",
    "../ModalModulos.svelte",
    "../ModalProjectName.svelte",
    "../Sidebar.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"typescript\">import AppCanvas from './AppCanvas.svelte';\nimport Canvas from './Canvas.svelte';\nimport { onMount } from 'svelte';\nimport { Module, Port, Connection, Chart } from './StructureLogic';\nimport Sidebar from './Sidebar.svelte';\nimport { addModule, removeModule } from './ChartInteraction';\nvar fs = require('fs');\nvar dir = '../MyFlowProjects';\nlet Chart0 = new Chart('Old Project');\n//need to initialize vars\nlet Background_dxInitial = -3000;\nlet Background_dyInitial = -3000;\n//positions where a module may \"spawn\"\nlet Background_dx;\nlet Background_dy;\nlet SpawnX = -Background_dxInitial + 600;\nlet SpawnY = -Background_dxInitial + 600;\nconst handleBackGroundMovement = (e) => {\n    Background_dx = e.detail.Background_dx.Background_dx;\n    Background_dy = e.detail.Background_dy.Background_dy;\n    SpawnX = -Background_dx + 600;\n    SpawnY = -Background_dy + 600;\n};\n//bunch of inputs/outputs for a module\nlet InputObject0 = new Port(true, 'String', 'IN');\nlet InputObject1 = new Port(true, 'String', 'INININ');\nlet OutputObject0 = new Port(false, 'String', 'nooo');\nlet OutputObject1 = new Port(false, 'String', 'out out out out');\nlet FlowModuleObject = new Module(0, 'modulo0', 3000, 3300);\nFlowModuleObject.addOutputs([OutputObject0, OutputObject1]);\nFlowModuleObject.addInputs([InputObject0, InputObject1]);\nFlowModuleObject.setModuleWidth();\nFlowModuleObject.setModuleHeight();\nFlowModuleObject.setPortCoords();\nlet InputObject2 = new Port(true, 'String', 'jesus & devil');\nlet InputObject3 = new Port(true, 'String', 'hello good sir');\nlet OutputObject2 = new Port(false, 'String', 'nooo');\nlet OutputObject3 = new Port(false, 'String', 'ole');\nlet FlowModuleObject2 = new Module(1, 'exemplo2', 2700, 2900);\nFlowModuleObject2.addOutputs([OutputObject2, OutputObject3]);\nFlowModuleObject2.addInputs([InputObject2, InputObject3]);\nFlowModuleObject2.setModuleWidth();\nFlowModuleObject2.setModuleHeight();\nFlowModuleObject2.setPortCoords();\nlet connection0 = new Connection('connectionX', InputObject0, true, FlowModuleObject);\nconnection0.setConnectedPort(OutputObject3, FlowModuleObject2);\nFlowModuleObject.addInputConnection(InputObject0, OutputObject1, FlowModuleObject2, connection0);\nFlowModuleObject2.addOutputConnection(OutputObject3, InputObject0, FlowModuleObject, connection0);\nconnection0.calculateCurve();\nChart0.addFinalConnection(connection0);\nChart0.addModule(FlowModuleObject);\nChart0.addModule(FlowModuleObject2);\nlet InputObject4 = new Port(true, 'String', 'IN');\nlet OutputObject4 = new Port(false, 'String', 'nooo');\nlet FlowModuleObject3 = new Module(3, 'exemplo3', 3700, 3600);\nFlowModuleObject3.addOutputs([OutputObject4]);\nFlowModuleObject3.addInputs([InputObject4]);\nFlowModuleObject3.setModuleWidth();\nFlowModuleObject3.setModuleHeight();\nFlowModuleObject3.setPortCoords();\n//addModule(Chart0, FlowModuleObject3) \n//removeModule(Chart0, FlowModuleObject);\n//reset\n//Chart0 = new Chart('New Project');\n//console.log(Chart0);\n//conditon to swithc canvas here needed to be implemented\nlet activeChart = Chart0;\nlet myCanvas;\nconst handleSaveProject = (e) => {\n    let ProjectName = e.detail.name;\n    //TODO not the  ideal solution\n    let chart = activeChart;\n    var obj = {\n        \"title\": chart.ProjectName,\n        \"Modules\": []\n    };\n    let i;\n    if (chart.ModuleList.length) {\n        for (i = 0; i < chart.ModuleList.length; i++) {\n            let module_obj = {\n                \"Name\": chart.ModuleList[i].name,\n                \"Id\": i,\n                \"Coord\": {\n                    \"CoordX\": chart.ModuleList[i].xPos,\n                    \"CoordY\": chart.ModuleList[i].yPos\n                },\n                \"FunctionID\": chart.ModuleList[i].functionId,\n                \"IO\": {\n                    \"Inputs\": [],\n                    \"Outputs\": []\n                },\n                \"Connections\": {\n                    \"Inputs\": [],\n                    \"Outputs\": []\n                }\n            };\n            let j;\n            for (j = 0; j < chart.ModuleList[i].inputList.length; j++) {\n                let inputPortObj = {\n                    \"PortID\": j,\n                    \"PortType\": chart.ModuleList[i].inputList[j].varType,\n                    \"VarName\": chart.ModuleList[i].inputList[j].varName\n                };\n                module_obj[\"IO\"][\"Inputs\"].push(inputPortObj);\n                let connectionIndex;\n                if (chart.ModuleList[i].connectionsInputs !== undefined) {\n                    for (connectionIndex = 0; connectionIndex < chart.ModuleList[i].connectionsInputs.length; connectionIndex++) {\n                        if (chart.ModuleList[i].connectionsInputs[connectionIndex].InternalPort.id == j) {\n                            let connectionObj = {\n                                \"ModuleID\": chart.ModuleList[i].connectionsInputs[connectionIndex].ExternalNode.id,\n                                \"ModulePort\": chart.ModuleList[i].connectionsInputs[connectionIndex].ExternalPort.id,\n                                \"InputPort\": j\n                            };\n                            module_obj[\"Connections\"][\"Inputs\"].push(connectionObj);\n                        }\n                    }\n                }\n                if (chart.ModuleList[i].connectionsOutputs !== undefined) {\n                    for (connectionIndex = 0; connectionIndex < chart.ModuleList[i].connectionsOutputs.length; connectionIndex++) {\n                        if (chart.ModuleList[i].connectionsOutputs[connectionIndex].InternalPort.id == j) {\n                            let connectionObj = {\n                                \"ModuleID\": chart.ModuleList[i].connectionsOutputs[connectionIndex].ExternalNode.id,\n                                \"ModulePort\": chart.ModuleList[i].connectionsOutputs[connectionIndex].ExternalPort.id,\n                                \"OutputPort\": j\n                            };\n                            module_obj[\"Connections\"][\"Outputs\"].push(connectionObj);\n                        }\n                    }\n                }\n            }\n            obj[\"Modules\"].push(module_obj);\n        }\n    }\n    var json = JSON.stringify(obj);\n    //create directory with files\n    if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir);\n    }\n    fs.writeFile('../MyFlowProjects/' + ProjectName + '.json', json, (err) => {\n        if (err) {\n            alert(\"An error ocurred creating the file \" + err.message);\n        }\n        alert(\"The file has been succesfully saved\");\n    });\n};\nconst handleAddModule = (e) => {\n    Chart0.findIdealModuleId(0);\n    let TemplateModule = e.detail.module;\n    let ModuleToBeAdded = new Module(Chart0.nextModuleID);\n    for (let i = 0; i < TemplateModule.listInputs.length; i++) {\n        let PortToBeAdded = new Port(TemplateModule.listInputs[i].isInput, TemplateModule.listInputs[i].varType, TemplateModule.listInputs[i].varName);\n        ModuleToBeAdded.inputList.push(PortToBeAdded);\n    }\n    for (let i = 0; i < TemplateModule.listOutputs.length; i++) {\n        let PortToBeAdded = new Port(TemplateModule.listOutputs[i].isInput, TemplateModule.listOutputs[i].varType, TemplateModule.listOutputs[i].varName);\n        ModuleToBeAdded.outputList.push(PortToBeAdded);\n    }\n    ModuleToBeAdded.name = TemplateModule.name;\n    ModuleToBeAdded.setXPos(SpawnX);\n    ModuleToBeAdded.setYPos(SpawnY);\n    ModuleToBeAdded.setModuleWidth();\n    ModuleToBeAdded.setModuleHeight();\n    ModuleToBeAdded.setPortCoords();\n    activeChart.ModuleList.push(ModuleToBeAdded);\n    activeChart.ModuleList = activeChart.ModuleList;\n    //not great logic here... should separate all of this\n    //used to help rendering... it was adding but did not show until i moved a module\n    //and so, updated the chart\n    Chart0 = activeChart;\n};\n</script>\n\n<div id=\"WorkingCanvas\">\n    <!--<AppCanvas \n            bind:this={myCanvas}\n            ChartStruc={Chart0}/>-->\n\n     <Canvas \n        on:BackgroundMovement={handleBackGroundMovement}\n        ChartStruc={Chart0}\n        Background_dx={Background_dxInitial}\n        Background_dy={Background_dyInitial}\n        />\n\n    <Sidebar \n            on:SaveProject={handleSaveProject}\n            on:AddModule={handleAddModule}\n            />\n\n</div>\n<style>\n    #WorkingCanvas {\n        z-index: -1;\n        height: 100%;\n        width: 80%;\n        background-color:rgb(92, 20, 44);\n    }\n    #BarModulesForAdding {\n        height: 100%;\n        width: 20%;\n        background-color:rgb(83, 71, 75);\n    }\n</style>",
    "\n<button type=\"button\" class=\"btn btn-info\"  on:click>\n    <slot />\n</button>\n<style>\n    button {\n        float: center;\n        z-index: 11;\n        opacity: 1;\n        background-color: #2196F3;\n        color:white;\n        border:black;\n        width:160px;\n        height: 50px;\n        padding-top: 15px;\n        }\n    button:hover {\n        float: center;\n        z-index: 11;\n        opacity: 1;\n        background-color: rgb(108, 183, 245);\n        color:white;\n        border:black;\n        width:160px;\n        height: 50px;\n        padding-top: 15px;\n        }\n</style>\n",
    "<script lang=\"typescript\">import FlowModule from './FlowModule.svelte';\nimport ConnectionSVG from './ConnectionSVG.svelte';\nimport { onMount } from 'svelte';\nimport { Module, Port, Connection, Chart } from './StructureLogic';\nimport { spring } from 'svelte/motion';\nimport { draggable } from './draggable.js';\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\nexport let ChartStruc;\n//TODO allow dragging the chart --> need to chage values here and send it somehow to the modules so handlers can work properly\nlet dx = 0;\nlet dy = 0;\n// if Background_dx & dy is changed, it represents the ammount of space that is already dragged from the background(canvas)\nexport let Background_dx;\nexport let Background_dy;\nconst handleDragMoveBackground = (e) => {\n    let { dx: _dx, dy: _dy } = e.detail;\n    dx += _dx;\n    dy += _dy;\n    Background_dx += _dx;\n    Background_dy += _dy;\n    dispatch('BackgroundMovement', {\n        Background_dx: { Background_dx },\n        Background_dy: { Background_dy }\n    });\n};\n//ggotta be global and export from app maybe.. so other \"apps\" can access\nvar connections = [];\n//verify if given coords represent a port and if it has certain PortType //TODO O(n**2) not a good thing\nfunction verifyCoordsIsPortFromType(CoordX, CoordY, originalPort, originalModule) {\n    for (let module of ChartStruc.ModuleList) {\n        //se a porta inicial for input so vamos avaliar outputs e vice versa\n        if (originalPort.isInput == false) {\n            for (let input of module.inputList) {\n                if (input.xPos - input.hiboxSize <= CoordX && input.xPos + input.hiboxSize >= CoordX) {\n                    if (input.yPos - input.hiboxSize <= CoordY && input.yPos + input.hiboxSize >= CoordY) {\n                        //we need to know if the types are the same\n                        if (input.varType == originalPort.varType) {\n                            //TODO nomes dinamicos\n                            let name = 'connection' + ChartStruc.ModuleList.length;\n                            let connection = new Connection(name, originalPort, originalPort.isInput, originalModule, module, input);\n                            connection.setConnectedPort(input, module);\n                            //inputmodule\n                            //InternalPort: Port, ExternalPort: Port, ExternalNode: Module, Connection: Connection)\n                            originalModule.addOutputConnection(originalPort, input, module, connection);\n                            //outputmodule\n                            //InternalPort: Port, ExternalPort: Port, ExternalNode: Module, Connection: Connection\n                            module.addInputConnection(input, originalPort, originalModule, connection);\n                            connection.calculateCurve();\n                            ChartStruc.FinalConnections.push(connection);\n                            ChartStruc.FinalConnections = ChartStruc.FinalConnections;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            for (let output of module.outputList) {\n                if (output.xPos - output.hiboxSize <= CoordX && output.xPos + output.hiboxSize >= CoordX) {\n                    if (output.yPos - output.hiboxSize <= CoordY && output.yPos + output.hiboxSize >= CoordY) {\n                        //we need to know the port of the module now\n                        if (output.varType == originalPort.varType) {\n                            //TODO nomes dinamicos\n                            let name = 'connection' + ChartStruc.ModuleList.length;\n                            let connection = new Connection(name, originalPort, originalPort.isInput, originalModule, module, output);\n                            connection.setConnectedPort(output, module);\n                            //inputmodule\n                            //InternalPort: Port, ExternalPort: Port, ExternalNode: Module, Connection: Connection)\n                            originalModule.addInputConnection(originalPort, output, module, connection);\n                            //outputmodule\n                            //InternalPort: Port, ExternalPort: Port, ExternalNode: Module, Connection: Connection\n                            module.addOutputConnection(output, originalPort, originalModule, connection);\n                            connection.calculateCurve();\n                            ChartStruc.FinalConnections.push(connection);\n                            ChartStruc.FinalConnections = ChartStruc.FinalConnections;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n//TODO posso nao tar sempre a criar e dar simplesment update as ligacoes\nconst handleDragEnd = (e) => {\n    let moduleDragged;\n    moduleDragged = e.detail.Module;\n    let dx = e.detail.dx.dx;\n    let dy = e.detail.dy.dy;\n    let lastX = e.detail.lastX.lastX;\n    let lastY = e.detail.lastY.lastY;\n    //TODO ma logica a dar coord no modulo\n    for (let moduleentry of ChartStruc.ModuleList) {\n        if (moduleentry.id == moduleDragged.StrucModule.id) {\n            moduleentry.setPortCoords();\n            if (moduleentry.connectionsInputs !== undefined) {\n                for (let inputconnection of moduleentry.connectionsInputs) {\n                    inputconnection.Connection.calculateCurve();\n                    for (let finalconnection of ChartStruc.FinalConnections) {\n                        if (finalconnection.id == inputconnection.Connection.id) {\n                            finalconnection = inputconnection;\n                        }\n                    }\n                }\n            }\n            if (moduleentry.connectionsOutputs !== undefined) {\n                for (let outputconnection of moduleentry.connectionsOutputs) {\n                    outputconnection.Connection.calculateCurve();\n                    for (let finalconnection of ChartStruc.FinalConnections) {\n                        if (finalconnection.id == outputconnection.Connection.id) {\n                            finalconnection = outputconnection;\n                        }\n                    }\n                }\n            }\n        }\n        ChartStruc.FinalConnections = ChartStruc.FinalConnections;\n    }\n};\nconst handleDragMove = (e) => {\n    let moduleDragged;\n    moduleDragged = e.detail.Module;\n    let dx = e.detail.dx.dx;\n    let dy = e.detail.dy.dy;\n    let lastX = e.detail.lastX.lastX;\n    let lastY = e.detail.lastY.lastY;\n    //TODO\n    for (let moduleentry of ChartStruc.ModuleList) {\n        if (moduleentry.id == moduleDragged.StrucModule.id) {\n            moduleentry.setPortCoords();\n            if (moduleentry.connectionsInputs !== undefined) {\n                for (let inputconnection of moduleentry.connectionsInputs) {\n                    inputconnection.Connection.calculateCurve();\n                    for (let finalconnection of ChartStruc.FinalConnections) {\n                        if (finalconnection.id == inputconnection.Connection.id) {\n                            finalconnection = inputconnection;\n                        }\n                    }\n                }\n            }\n            if (moduleentry.connectionsOutputs !== undefined) {\n                for (let outputconnection of moduleentry.connectionsOutputs) {\n                    outputconnection.Connection.calculateCurve();\n                    for (let finalconnection of ChartStruc.FinalConnections) {\n                        if (finalconnection.id == outputconnection.Connection.id) {\n                            finalconnection = outputconnection;\n                        }\n                    }\n                }\n            }\n        }\n        ChartStruc.FinalConnections = ChartStruc.FinalConnections;\n    }\n};\nconst handleConnectionStart = (e) => {\n    let { xInitial, xFinal, yInitial, yFinal, port, parentModule } = e.detail;\n    //TODO id da conexao dinamicamente\n    let connection = new Connection('tentativa', port.port.port.port, port.port.port.port.isInput, parentModule.StrucModule);\n    connection.setEndPoints(xFinal.xFinal.xFinal - Background_dx, yFinal.yFinal.yFinal - Background_dy);\n    connection.calculateCurve();\n    connections.push(connection);\n    connections = connections;\n};\nconst handleConnectionDrag = (e) => {\n    let { xInitial, xFinal, yInitial, yFinal, port, parentModule } = e.detail;\n    connections = [];\n    //TODO id da conexao dinamicamente\n    let connection = new Connection('tentativa', port.port.port.port, port.port.port.port.isInput, parentModule.StrucModule);\n    connection.setEndPoints(xFinal.xFinal.xFinal - Background_dx, yFinal.yFinal.yFinal - Background_dy);\n    connection.calculateCurve();\n    connections.push(connection);\n    connections = connections;\n};\nconst handleConnectionEnd = (e) => {\n    let { xInitial, xFinal, yInitial, yFinal, port, parentModule } = e.detail;\n    connections = [];\n    verifyCoordsIsPortFromType(xFinal.xFinal.xFinal - Background_dx, yFinal.yFinal.yFinal - Background_dy, port.port.port.port, parentModule.StrucModule);\n};\n</script>\n<svg    use:draggable  \n        on:dragmove={handleDragMoveBackground}\n        transform={`translate(${Background_dx} ${Background_dy})`} >\n\t<g>  \n            {#each ChartStruc.ModuleList as moduleEntry,i (i)}\n                <FlowModule \n                StrucModule={moduleEntry} \n                on:handleDragEnd={handleDragEnd}\n                on:handleDragMove={handleDragMove}\n                on:handleConnectionStart={handleConnectionStart}\n                on:handleConnectionDrag={handleConnectionDrag}\n                on:handleConnectionEnd={handleConnectionEnd}\n                /> \n            {/each}\n\n            {#each connections as connection,i (i)}\n                <path d={connection.curve} fill=\"transparent\"/>\n            {/each}\n            {#each ChartStruc.FinalConnections as connection,i (i)}\n                <ConnectionSVG \n                    connection={connection}\n                    />\n            {/each}\n            \n    </g>\n</svg>\n<style>\n    svg{\n        background-color: rgb(92, 20, 44);\n        width: 1000%; \n        height: 1000% \n    }\n\n    path{\n        stroke-width: 5;\n        stroke-opacity: 0.5;\n        stroke:#ff3e00;\n\n    }\n\tcircle { fill: #ff3e00; opacity:1;z-index: 1 }\n\tcircle:hover { fill: #a50c25; opacity:1;z-index: 1}\n</style>",
    "<script lang=\"typescript\">import { Connection } from './StructureLogic';\nexport let connection;\n</script>\n\n<path d={connection.curve} fill=\"transparent\"/>\n<circle cx={connection.parentPort.xPos} cy={connection.parentPort.yPos} r=\"5\" />\n<circle cx={connection.externalPort.xPos} cy={connection.externalPort.yPos} r=\"5\" />\n\n<style>\n\n    path{\n        stroke-width: 5;\n        stroke-opacity: 0.5;\n        stroke:#ff3e00;\n\n    }\n\tcircle { \n        fill: #ff3e00; \n        opacity:1;\n    }\n\tcircle:hover { \n        fill: #a50c25; \n        opacity:1;\n    }\n\n</style>",
    "<script lang=\"typescript\">import FlowModuleContent from './FlowModuleContent.svelte';\nimport FlowModuleHeader from './FlowModuleHeader.svelte';\nimport { spring } from 'svelte/motion';\nimport { draggable } from './draggable';\nimport { Module, Port, Connection } from './StructureLogic';\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\nexport let StrucModule;\nlet xPos = StrucModule.getXPos();\nlet yPos = StrucModule.getYPos();\n//this needs to be dynamic due to the number of outputs and inputs\nlet moduleHeight = StrucModule.getModuleHeight(); //size of the header\nlet contentHeight = StrucModule.getContentHeight();\nlet moduleWidth = StrucModule.getModuleWidth();\n//TODO verify types of list here to ts\n//if i want to access rect from component's parent (chart) -> add export\nlet rect;\n//draggable vars\nlet dx = 0;\nlet dy = 0;\n//in order to set x and y pos correctly on the module, we need to revert previous transformations changes (dx, dy)\nlet lastdx = 0;\nlet lastdy = 0;\nconst handleDragMove = (e) => {\n    let { lastX: lastX, lastY: lastY, dx: _dx, dy: _dy } = e.detail;\n    rect.setAttribute('stroke-width', '14px');\n    dx += _dx;\n    dy += _dy;\n    let moduleX = StrucModule.getXPos();\n    let moduleY = StrucModule.getYPos();\n    StrucModule.setXPos(moduleX + dx - lastdx);\n    StrucModule.setYPos(moduleY + dy - lastdy);\n    dispatch('handleDragMove', {\n        Module: { StrucModule },\n        lastX: { lastX },\n        lastY: { lastY },\n        dx: { dx },\n        dy: { dy }\n    });\n    lastdx = dx;\n    lastdy = dy;\n};\nconst handleDragEnd = (e) => {\n    let { lastX, lastY } = e.detail;\n    rect.setAttribute('stroke', 'green');\n    rect.setAttribute('stroke-width', '0px');\n    let moduleX = StrucModule.getXPos();\n    let moduleY = StrucModule.getYPos();\n    StrucModule.setXPos(moduleX + dx - lastdx);\n    StrucModule.setYPos(moduleY + dy - lastdy);\n    dispatch('handleDragEnd', {\n        Module: { StrucModule },\n        lastX: { lastX },\n        lastY: { lastY },\n        dx: { dx },\n        dy: { dy }\n    });\n    lastdx = dx;\n    lastdy = dy;\n};\nconst handleDragStart = (e) => {\n    let { lastX, lastY } = e.detail;\n    rect.setAttribute('stroke', 'green');\n    rect.setAttribute('stroke-width', '10px');\n};\nconst handleConnectionStart = (e) => {\n    let { xInitial, xFinal, yInitial, yFinal, port } = e.detail;\n    dispatch('handleConnectionStart', {\n        xInitial: { xInitial },\n        xFinal: { xFinal },\n        yInitial: { yInitial },\n        yFinal: { yFinal },\n        port: { port },\n        parentModule: { StrucModule }\n    });\n};\nconst handleConnectionDrag = (e) => {\n    let { xInitial, xFinal, yInitial, yFinal, port } = e.detail;\n    dispatch('handleConnectionDrag', {\n        xInitial: { xInitial },\n        xFinal: { xFinal },\n        yInitial: { yInitial },\n        yFinal: { yFinal },\n        port: { port },\n        parentModule: { StrucModule }\n    });\n};\nconst handleConnectionEnd = (e) => {\n    let { xInitial, xFinal, yInitial, yFinal, port } = e.detail;\n    dispatch('handleConnectionEnd', {\n        xInitial: { xInitial },\n        xFinal: { xFinal },\n        yInitial: { yInitial },\n        yFinal: { yFinal },\n        port: { port },\n        parentModule: { StrucModule }\n    });\n};\n</script>\n<svelte:options accessors></svelte:options>\n\n<g class=\"node-container\" \n    transform={`translate(${dx} ${dy})`}  >     \n\t<rect \n        bind:this={rect} \n        class=\"node-background\" \n        x={xPos} \n        y={yPos} \n        width={moduleWidth} \n        height={moduleHeight} \n        rx=\"6\" \n        ry=\"6\" />\t\n    <g             \n        use:draggable  \n        on:dragmove={handleDragMove}\n        on:dragstart={handleDragStart}   \n        on:dragend={handleDragEnd}>\n\t    <FlowModuleHeader \n            ModuleName={StrucModule.getName()} \n            moduleWidth={moduleWidth} \n            xPos={xPos} \n            yPos={yPos}/>\n    </g>\t\n    <!-- TODO headerHeight nao dinamico-->\n    <FlowModuleContent \n        moduleWidth={moduleWidth} \n        xPos={xPos} \n        yPos={yPos} \n        OutputList={StrucModule.getOutputList()} \n        InputList={StrucModule.getInputList()} \n        contentHeight={contentHeight}\n        on:handleConnectionStart={handleConnectionStart}\n        on:handleConnectionDrag={handleConnectionDrag}\n        on:handleConnectionEnd={handleConnectionEnd}/> \t\t\n\n</g>\n<style>\n\t.node-container {\n\tcursor: move;\n\t}\n\t.node-background {\n\tfill: #1a1c1d;\n\t}\n\t/*connectors to be added*/\n\t.connector-handle {\n\tfill: rgb(43, 107, 18);\n\t}\n\t.connector-handle:hover{\n\tfill: rgb(67, 232, 2);\n\t}\n\t.connector-path {\n\tstroke: rgb(2, 178, 232);\n\tstroke-width: 4;\n\tfill: none;\n\t}\n\t.connector-path:hover {\n\tstroke: rgb(153, 3, 48);\n\tstroke-width: 6;\n\tfill: none;\n\t}\n\t.connector-path-outline {\n\tstroke: #333;\n\tstroke-width: 6;\n\tfill: none;\n\t}\n</style>",
    "<script lang=\"typescript\">import FlowModuleInput from './FlowModuleInput.svelte';\nimport FlowModuleOutput from './FlowModuleOutput.svelte';\nimport { Module, Port, Connection } from './StructureLogic';\nimport { createEventDispatcher } from 'svelte';\nexport let xPos;\nexport let yPos;\nexport let moduleWidth;\nexport let OutputList;\nexport let InputList;\n//it changes due to the number of inputs\nexport let contentHeight;\nlet contentHeightRect = contentHeight - 5;\n//if needed to change or adjust the background of the content\nlet contentRectX = xPos + 2;\nlet contentRectY = yPos + 44; //40 is the header size... can make it a attribute later //TODO\nconst dispatch = createEventDispatcher();\nconst handleConnectionStart = (e) => {\n    let { xInitial, xFinal, yInitial, yFinal, port } = e.detail;\n    dispatch('handleConnectionStart', {\n        xInitial: { xInitial },\n        xFinal: { xFinal },\n        yInitial: { yInitial },\n        yFinal: { yFinal },\n        port: { port }\n    });\n};\nconst handleConnectionDrag = (e) => {\n    let { xInitial, xFinal, yInitial, yFinal, port } = e.detail;\n    dispatch('handleConnectionDrag', {\n        xInitial: { xInitial },\n        xFinal: { xFinal },\n        yInitial: { yInitial },\n        yFinal: { yFinal },\n        port: { port }\n    });\n};\nconst handleConnectionEnd = (e) => {\n    let { xInitial, xFinal, yInitial, yFinal, port } = e.detail;\n    dispatch('handleConnectionEnd', {\n        xInitial: { xInitial },\n        xFinal: { xFinal },\n        yInitial: { yInitial },\n        yFinal: { yFinal },\n        port: { port }\n    });\n};\n</script>\n\n<g class=\"node-content\">\n    <rect class=\"content-round-rect\" width={moduleWidth} height={contentHeight} x={contentRectX} y={contentRectY} rx=\"4\" ry=\"4\" />\n    <rect class=\"content-rect\" width={moduleWidth} height={contentHeightRect}  x={contentRectX} y={contentRectY} />\n    <g class=\"inputs\">\t\n        {#each InputList as item, i (i)}\n            <FlowModuleInput \n                port={item} \n                xPos={xPos} \n                yPos={yPos} \n                portNumber={i} \n                varType={item.getVarType()} \n                varName={item.getVarName()}\n                on:handleConnectionStart={handleConnectionStart}\n                on:handleConnectionDrag={handleConnectionDrag}\n                on:handleConnectionEnd={handleConnectionEnd}/>\n        {/each}\n    </g>    \n    <g class=\"outputs\">\n        {#each OutputList as item, i (i)}\n            <FlowModuleOutput \n                port={item} \n                xPos={xPos} \n                yPos={yPos} \n                portNumber={i} \n                moduleWidth={moduleWidth} \n                varType={item.getVarType()} \n                varName={item.getVarName()}\n                on:handleConnectionStart={handleConnectionStart}\n                on:handleConnectionDrag={handleConnectionDrag}\n                on:handleConnectionEnd={handleConnectionEnd}/>\n        {/each}\n    </g>\n    \n</g>\n\n<style>\n\t.node-content {\n\tfill: #3C3C3C;\n\t}\n</style> ",
    "<script lang=\"typescript\">export let ModuleName;\nexport let moduleWidth;\nexport let xPos;\nexport let yPos;\nlet xPosHeader = xPos + 2;\nlet yPosHeader = yPos + 2;\nlet headerTitleX = xPosHeader + moduleWidth / 2;\nlet headerTitleY = yPosHeader + 30;\n//alterar possivelmente o fundo do header e ajustar\nlet headerRectX = xPos;\nlet headerRectY = yPos;\n</script>\n<g class=\"node-header\">\n    <rect class=\"header-round-rect\" width={moduleWidth} height=\"40\" x={xPosHeader} y={yPosHeader} rx=\"4\" ry=\"4\" />\n    <rect class=\"header-rect\" width={moduleWidth} height=\"36\" x={headerRectX} y={headerRectY} />\n    <text class=\"header-title\" x={headerTitleX} y={headerTitleY}>{ModuleName}</text>\n</g>\n\n<style>\n    .node-header {\n\tfill: #2196F3;\n\t}\n\t.node-header .header-title {\n\tfont-size: 20px;\n\tfill: #fff;\n\ttext-anchor: middle;\n\t}\n</style>",
    "\n<script lang=\"typescript\">import { createEventDispatcher } from 'svelte';\nimport { Module, Port } from './StructureLogic';\nimport { connections } from './connections';\n//corresponds to the number of the port, of its the 1st, 2nd,...\nexport let portNumber;\nexport let varType;\nexport let varName;\nexport let port;\nexport let xPos;\nexport let yPos;\nlet cx = xPos + 15;\nlet cy = yPos + 10;\nlet portLabelX = xPos + 28;\nlet portLabelY = yPos + 14;\nlet transformValue = 50 + (25 * portNumber);\nlet cyRealValue = cy + transformValue;\nlet space = ' ';\nport.setXPos(cx);\nport.setYPos(cyRealValue);\nport.setId(portNumber);\nconst dispatch = createEventDispatcher();\nconst handleConnectionStart = (e) => {\n    let { lastX, lastY } = e.detail;\n    dispatch('handleConnectionStart', {\n        xInitial: cx,\n        xFinal: lastX,\n        yInitial: cyRealValue,\n        yFinal: lastY,\n        port: { port }\n    });\n};\nconst handleConnectionDrag = (e) => {\n    let { lastX, lastY, dx, dy } = e.detail;\n    dispatch('handleConnectionDrag', {\n        xInitial: cx,\n        xFinal: lastX,\n        yInitial: cyRealValue,\n        yFinal: lastY,\n        port: { port }\n    });\n};\nconst handleConnectionEnd = (e) => {\n    let { lastX, lastY, dx, dy } = e.detail;\n    dispatch('handleConnectionEnd', {\n        xInitial: cx,\n        xFinal: lastX,\n        yInitial: cyRealValue,\n        yFinal: lastY,\n        port: { port }\n    });\n};\n</script>\n\n\n\n<g class=\"input-field\" transform=\"translate(0, {transformValue})\">\n\t<g class=\"port\" \n\t\t\t\tuse:connections\n\t\t\t\ton:connectionDrag={handleConnectionDrag}\n\t\t\t\ton:connectionStart={handleConnectionStart}\n\t\t\t\ton:connectionEnd={handleConnectionEnd}>\n\t\t<circle class=\"port-outer\" cx={cx} cy={cy} r=\"7.5\" />\n\t\t<circle class=\"port-inner\" cx={cx} cy={cy} r=\"5\" />\n\t\t<circle class=\"port-scrim\" cx={cx} cy={cy} r=\"7.5\" />\n\t</g>\n\t<text class=\"port-label\" x={portLabelX} y={portLabelY}>{varType} {space} {varName}</text>\n</g>\n\n<style>\n\t.port {\n\tcursor: pointer;\n\t}\n\t.port-scrim {\n\tfill: transparent;\n\t}\n\t.port-outer {\n\tfill: #777777;\n\t}\n\t.port-inner {\n\tfill: #202020;\n\t}\n\t.port-label {\n\tfont-size: 12px;\n\tfill: #fff;\n\t}\n\t.input-field .port-label {\n\ttext-anchor: start;\n\t}\n</style>",
    "<script lang=\"typescript\">import { createEventDispatcher } from 'svelte';\nimport { Module, Port } from './StructureLogic';\nimport { connections } from './connections';\n//corresponds to the number of the port, of its the 1st, 2nd,...\nexport let portNumber;\nexport let varType;\nexport let varName;\nexport let port;\nexport let xPos;\nexport let yPos;\nexport let moduleWidth;\nlet cx = xPos + moduleWidth - 11;\nlet cy = yPos + 10;\nlet portLabelX = xPos + moduleWidth - 24;\nlet portLabelY = yPos + 14;\nlet transformValue = 50 + (25 * portNumber);\nlet cyRealValue = cy + transformValue;\nlet space = ' ';\nport.setXPos(cx);\nport.setYPos(cyRealValue);\nport.setId(portNumber);\nconst dispatch = createEventDispatcher();\nconst handleConnectionStart = (e) => {\n    let { lastX, lastY } = e.detail;\n    dispatch('handleConnectionStart', {\n        xInitial: cx,\n        xFinal: lastX,\n        yInitial: cyRealValue,\n        yFinal: lastY,\n        port: { port }\n    });\n};\nconst handleConnectionDrag = (e) => {\n    let { lastX, lastY, dx, dy } = e.detail;\n    dispatch('handleConnectionDrag', {\n        xInitial: cx,\n        xFinal: lastX,\n        yInitial: cyRealValue,\n        yFinal: lastY,\n        port: { port }\n    });\n};\nconst handleConnectionEnd = (e) => {\n    let { lastX, lastY, dx, dy } = e.detail;\n    dispatch('handleConnectionEnd', {\n        xInitial: cx,\n        xFinal: lastX,\n        yInitial: cyRealValue,\n        yFinal: lastY,\n        port: { port }\n    });\n};\n</script>\n\n\n<g class=\"output-field\" transform=\"translate(0, {transformValue})\">\n    <g class=\"port\" \n\t\t\t\tuse:connections\n\t\t\t\ton:connectionDrag={handleConnectionDrag}\n\t\t\t\ton:connectionStart={handleConnectionStart}\n\t\t\t\ton:connectionEnd={handleConnectionEnd}>\n        <circle class=\"port-outer\" cx={cx} cy={cy} r=\"7.5\" />\n        <circle class=\"port-inner\" cx={cx} cy={cy} r=\"5\" />\n        <circle class=\"port-scrim\" cx={cx} cy={cy} r=\"7.5\" />\n    </g>\n    <text class=\"port-label\" x={portLabelX} y={portLabelY}>{varType} {space} {varName}</text>\n</g>\n\n\n\n\n<style>\n\t.port {\n\tcursor: pointer;\n\t}\n\t.port-scrim {\n\tfill: transparent;\n\t}\n\t.port-outer {\n\tfill: #777777;\n\t}\n\t.port-inner {\n\tfill: #202020;\n\t}\n\t.port-label {\n\tfont-size: 12px;\n\tfill: #fff;\n\t}\n\t.input-field .port-label {\n\ttext-anchor: start;\n\t}\n\t.output-field .port-label {\n\ttext-anchor: end;\n\t}\n</style>",
    "{#if show}\n<div>\n\n  <div class=\"modal-overlay\" data-close on:click={overlay_click} transition:fade={{duration: 150}}>\n    <div class=\"modal-container\">\n      <main><h1>ComputeFlow</h1>\n            <h4>https://github.com/DanielMoreiraPT/ComputeFlow</h4>\n            <h2>Computeflow is a final project for Informatics Engineering Bachlor's degree.</h2>\n            <p>It's goal is to develop software able to provide an intuitive and interactive Interface for users that require usage of data flow programming without having extensive programming knowledge.\n                Members</p>\n            <h2>Members</h2>    \n            <h3>Computation: </h3>\n                    <p>Aneta Pawelec (pawelec.aneta98@gmail.com)</p>\n                    <p>Daniel Moreira (danielbarbosa@ua.pt)</p>\n            <h3>Interface: </h3>\n                    <p>André Catarino (andre.catarino@ua.pt)</p>\n                    <p>Rui Melo (r.melo@ua.pt)</p>\n\n            <h2>Orientators</h2>   \n                <p>José Maria Fernandes (jfernan@ua.pt)</p>\n                <p>Sérgio Miguel Santos (sergio.santos@ua.pt)</p>\n                    \n            <h2>Supervisors</h2>   \n                <p>José Moreira (jose.moreira@ua.pt)</p>\n                <p>António Sousa Pereira (f185@ua.pt)</p>\n                <p>Rui Aguiar (ruilaa@ua.pt)</p>\n                \n    </main>\n    </div>\n  </div>\n</div>\n{/if}\n\n<script>\nimport { fade } from 'svelte/transition';\n\nfunction overlay_click(e) {\n    if ('close' in e.target.dataset)\n        show = false;\n}\n\nexport let show = false;\n</script>\n\n<style>\n.modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0.5);\n  z-index: 10;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n}\n.modal-container {\n  position: relative;\n  background-color:rgb(92, 20, 44);;\n  width: 90vw;\n  margin: 1rem auto 0.2rem;\n  box-shadow: 0 3px 10px #555;\n}\nmain {\n  padding: 0.5rem;\n  color: white;\n}\n</style>",
    "\n<script lang=\"typescript\">import { fade } from 'svelte/transition';\nimport { TemplateModule, TemplatePort } from './templates';\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\nimport Button from './Button.svelte';\nexport let show = false;\nfunction overlay_click(e) {\n    if ('close' in e.target.dataset)\n        show = false;\n}\nlet ModulesTemplatesList = [];\nlet ModuleVarList = [];\nlet ModuleFunctionList = [];\nfunction sendModuleInfo(ModuleTemplate) {\n    show = false;\n    dispatch('AddModule', {\n        module: ModuleTemplate\n    });\n}\n//read Templates for the Modules --> inside public dr\nvar fs = require('fs');\nvar path = require('path');\nvar filePath = path.join(__dirname, 'ModulesTemplates.json');\nfs.readFile(filePath, function (err, data) {\n    if (!err) {\n        let json = JSON.parse(data);\n        //console.log(json);\n        let i;\n        for (i = 0; i < json.Templates.Variables.length; i++) {\n            let tempVar = new TemplateModule(json.Templates.Variables[i].Name);\n            //como é var so vai ter outputs\n            let j;\n            for (j = 0; j < json.Templates.Variables[i].IO.Outputs.length; j++) {\n                let tempPort = new TemplatePort(false, json.Templates.Variables[i].IO.Outputs[j].PortType, json.Templates.Variables[i].IO.Outputs[j].VarName);\n                tempVar.listOutputs.push(tempPort);\n            }\n            //console.log(tempVar)\n            ModuleVarList.push(tempVar);\n        }\n        for (i = 0; i < json.Templates.Functions.length; i++) {\n            let tempVar = new TemplateModule(json.Templates.Functions[i].Name);\n            //como é function vai ter inputs e outputs\n            let j;\n            for (j = 0; j < json.Templates.Functions[i].IO.Inputs.length; j++) {\n                let tempPort = new TemplatePort(true, json.Templates.Functions[i].IO.Inputs[j].PortType, json.Templates.Variables[i].IO.Outputs[j].VarName);\n                tempVar.listInputs.push(tempPort);\n            }\n            for (j = 0; j < json.Templates.Functions[i].IO.Outputs.length; j++) {\n                let tempPort = new TemplatePort(false, json.Templates.Functions[i].IO.Outputs[j].PortType, json.Templates.Variables[i].IO.Outputs[j].VarName);\n                tempVar.listOutputs.push(tempPort);\n            }\n            //console.log(tempVar)\n            ModuleFunctionList.push(tempVar);\n        }\n    }\n    else {\n        console.log(err);\n    }\n});\n</script>\n\n{#if show}\n<div>\n\n  <div class=\"modal-overlay\" data-close on:click={overlay_click} transition:fade={{duration: 250}}>\n    <div class=\"modal-container\">\n        <main>\n            {#if ModuleVarList.length!=0}\n                <h1>Variables</h1>\n                {#each ModuleVarList as variable}\n                    <Button on:click={e => sendModuleInfo(variable)}>{variable.name}</Button>\n                {/each}\n            {:else}\n                <h1>No templates for Variables</h1>\n            {/if}\n            {#if ModuleFunctionList.length!=0}\n                <h1>Functions</h1>\n                {#each ModuleFunctionList as variable}\n                    <Button on:click={e => sendModuleInfo(variable)}>{variable.name}</Button>\n                {/each}\n            {:else}\n                <h1>No templates for Functions</h1>\n            {/if}\n\n        </main>\n    </div>\n  </div>\n</div>\n{/if}\n\n<style>\n.modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0.5);\n  z-index: 10;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n}\n.modal-container {\n  position: relative;\n  background-color:rgb(92, 20, 44);;\n  width: 90vw;\n  margin: 1rem auto 0.2rem;\n  box-shadow: 0 3px 10px #555;\n}\nmain {\n  padding: 0.5rem;\n  color: white;\n}\n\n</style>",
    "{#if show}\n<div>\n\n  <div class=\"modal-overlay\" data-close on:click={overlay_click} transition:fade={{duration: 150}}>\n    <div class=\"modal-container\">\n      <main>\n        <div> \n            <h1>Name: </h1>\n            <input bind:value={ProjectName}>\n        </div>\n        <div>\n            <Button on:click={saveProject}>Save</Button>\n        </div>\n    </main>\n    </div>\n  </div>\n</div>\n{/if}\n\n<script lang=\"typescript\">import Button from './Button.svelte';\nimport { fade } from 'svelte/transition';\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\nconst saveProject = (e) => {\n    show = false;\n    dispatch('SaveProjectAndName', {\n        name: ProjectName\n    });\n};\nfunction overlay_click(e) {\n    if ('close' in e.target.dataset)\n        show = false;\n}\nexport let ProjectName;\nexport let show = false;\n</script>\n\n<style>\n.modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0.5);\n  z-index: 10;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n}\n.modal-container {\n  position: relative;\n  background-color:rgb(92, 20, 44);;\n  width: 90vw;\n  margin: 1rem auto 0.2rem;\n  box-shadow: 0 3px 10px #555;\n}\nmain {\n  padding: 0.5rem;\n  color: white;\n}\nh1 {\n  color: white;\n}\n</style>",
    "<script lang=\"typescript\">import { fly } from 'svelte/transition';\nimport Modal from './Modal.svelte';\nimport ModalModulos from './ModalModulos.svelte';\nimport ModalProjectName from './ModalProjectName.svelte';\nimport Button from './Button.svelte';\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\nimport { TemplateModule, TemplatePort } from './templates';\nlet modal_show = false;\nlet modalModulos_show = false;\nlet modalProjectName_show = false;\nlet ProjectName;\nconst saveProject = (e) => {\n    if (ProjectName == undefined) {\n        modalProjectName_show = true;\n    }\n    else {\n        dispatch('SaveProject', {\n            name: ProjectName,\n        });\n    }\n};\nconst handleAddModule = (e) => {\n    dispatch('AddModule', {\n        module: e.detail.module\n    });\n};\nconst handlesaveProjectandName = (e) => {\n    ProjectName = e.detail.name;\n    dispatch('SaveProject', {\n        name: ProjectName,\n    });\n};\n</script>\n\n\n<nav>\n    <h1>ComputeFlow</h1>\n    {#if ProjectName == undefined}\n        <h4>New Project</h4>\n    {:else}\n        <h4>{ProjectName}</h4>\n    {/if}\n    <Button on:click={() => {modalModulos_show = true;}}>Add Module</Button>\n    <!--\n        <Button on:click={}>New Project</Button>\n    <Button on:click={}>Load Project</Button>\n    -->\n    <Button on:click={saveProject}>Save Project</Button>\n    <Button on:click={() => {modalProjectName_show = true;}}>Save Project as</Button>\n    <Button on:click={() => {modal_show = true;}}>About</Button>\n</nav>\n\n<Modal bind:show={modal_show} />\n<ModalModulos bind:show={modalModulos_show} on:AddModule={handleAddModule}/>\n<ModalProjectName bind:show={modalProjectName_show} ProjectName={ProjectName} on:SaveProjectAndName={handlesaveProjectandName}/>\n\n\t\t\n<style>\n    nav {\n        position: fixed;\n        top: 0;\n        left: 0;\n        height: 100%;\n        padding: 2rem 1rem 0.6rem;\n        border-left: 1px solid #aaa; \n        background: rgb(0, 0, 0);\n        opacity: 0.5;\n        overflow-y: auto;\n        width: 10rem;\n    }\n\n    h1, h4 {\n        color:white;\n    }\n</style>"
  ],
  "names": [],
  "mappings": "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"
}